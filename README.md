# MCDF_Design_Verification

## 运行仿真
    iverilog gtkwave
    cd sim

### 编译(可以改变tb模块名仿真其他模块)
    make compile TEST_NAME=tb_formatter

### 运行(出波形图)
    make all TEST_NAME=tb_formatter

## 多通道数据整形器(top_formatter)

多通道数据整形器MCDF（Multi-Channel Data Formatter），将多个通道的上行(uplink)数据经过内部的FIFO以数据包(data packet)的形式送出。
此模块的实现可分为几个模块——寄存器控制器，可以通过配置寄存器来配置整个模块的工作方式，包括数据包的大小、优先级；接收数据的slave_FIFO模块，作为从端接收外部数据，然后根据握手信号送出数据；arbiter数据仲裁器，当多个通道的数据来到时，根据请求情况和优先级仲裁出当前应进行传输的通道；formatter数据整形器，将不定数量的数据整形成特定数目的数据包后再输出。

## 寄存器控制器模块(ctrl_reg)

此模块的本质是对寄存器堆的读写，对每个通道都定义控制寄存器和状态寄存器，前者可读写，用于配置通道使能、优先级、数据包长度这三个通道属性；后者是只能读，可以读取每个通道的从端中FIFO的余量。
对于写指令的时序，指令、地址和写数据三者同步输入，就能完成数据写入；对于读指令的时序，给出指令和读地址的下一周期读数据就会被输出。
在写入寄存器后，使用组合逻辑直接将控制器中的控制信号输出；对于状态寄存器中的数据，直接从输入端口中的margin信号进行赋值，并且每个周期都需要更新。

对于寄存器控制器的验证输入读写指令，对所有的寄存器进行写入数据，然后读出数据，看数据是否一致并观察模块内部的寄存器变化情况即可。
给出指令和地址，可以看到在每一次完成写指令（cmd_i=0x10）后相应的使能信号、数据包长度和优先级就发生了变化，说明写入寄存器后能够输出正确的控制信号；在每一次完成读指令（cmd_i=0x01）后的下一个时钟上升沿相应寄存器里的数据就被读出，且读出的数据的正确的。

## slave_FIFO模块(FIFO64x32)

此模块的作用是根据通道输入的数据情况，将其写入FIFO中，再根据后续连接的arbiter数据仲裁器返回的响应信号来将FIFO中的数据读出。由于在之前的工作中同步FIFO已经实现参数化实现，包括深度和数据位宽，因此FIFO不需要额外实现，只需在例化时实现64个32位的FIFO即可。
因此，此模块需要实现部分是FIFO写使能信号的产生、FIFO满信号对外部信号的控制、FIFO读使能信号的产生、FIFO空信号的控制。

## 数据仲裁模块(arbiter)

此模块的作用是当后续的formatter整形器模块发起了一次请求仲裁信号req后，对从端的请求信号和各通道的优先级对请求进行仲裁，保证每次都是优先级最高的通道得到响应。在每次仲裁完毕后都会从后续的formatter整形器模块收到响应信号a2sx_ack_i，此信号往前传输给仲裁结果对应的通道，从而发起相应通道的数据输出，并输出寄存器控制器中数据包长度信号给下一个模块。

## 数据整形器模块(formatter)

此模块作用要从整个MCDF的功能来理解。首先，整个电路的功能是对多个通道输入的数据进行整合，比如通道0送入了100个数据，可能是连续或者不连续的。而我们的目的是将送入的一堆数据进行分段，即变为数据包格式，若数据包大小为32，则100个数据会变为3*32+4，即变为3个数据包和多的4个数据。即formatter整形器的意义是将数据变为数据包，而不是把32位的数据拆成4，8，16位的数据。
因此，我们可以构思数据流及其控制信号的处理方式。首先假定要整合的数据包是16个数据，然后从各通道送入数据，通道0送入10个数据，通道1送入20个，通道2送入30个数据，数据会存到各自的FIFO里；在默认优先级的情况下，通道0优先级大于通道1大于通道2。这里有个问题是，通道0虽然优先级高，但是它还不足16个数据，它应该发起一次传输请求（req）吗？如果发起了传输请求，但又一直没有数据补充进来，而最后的formatter整形器模块必须等到足够的数据才能够开始一次数据整合的传输，就卡住了，那为什么不先传输其他通道呢？因为formatter整形器不能同时看到所有通道中已有的数据，它只能拿到arbiter数据仲裁器给的数据，数据包长度，有效信号，arbiter数据仲裁器给了什么数据就用什么数据；同时各个通道和寄存器之间并没有端口连接，因此通道本身不知道要等到有多少数据才能发起传输请求，因此只要FIFO中有了数据就可以发起传输请求。因此，就需要在formatter整形器中有一个32（数据位宽）x32（最大深度）的ram，只有当ram中存满了所需的数据时，才往外部发起一次请求。这样才能保证formatter整形器输出的数据包的连续的完整的。


formatter整形器的设计是整个MCDF设计的最后一个模块，因此在验证时，可以联合上述所有已经完成并验证通过的模块共同进行仿真验证，以实现对完整的MCDF电路设计的验证。
本次电路验证的思路是在tb中先配置好寄存器，然后外部不断往各个通道中发送数据，但个通道之间的数据并不同步，优先级也不相同，这可以验证arbiter数据仲裁器是否工作正常；仲裁完成后数据会送入formatter整形器，可以对照仿真的波形和我们所绘制时序图，验证电路的功能是否正确，主要有两个方面。一是数据能否正常写入formatter整形器的ram中，然后存到足够数目的数据后再输出；二是再往外输出数据的时候，能否继续从arbiter数据仲裁器接收数据并存入ram中，保证两个过程是没有发生冲突的。然后tb中如果收到了MCDF输出的fmt_req信号，那就自动在下个周期回复fmt_grant信号；或者不回复fmt_grant信号，那么这个电路应处于停止工作的状态，因为外界不回复此信号说明不能继续进行数据传输了。
